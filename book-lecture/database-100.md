# 피그마는 어떻게 Database를 100배 확장할 수 있었는가(번역)

[100X Scaling: How Figma Scaled its Databases](https://blog.bytebytego.com/p/100x-scaling-how-figma-scaled-its)에 대해 요약한 글입니다.

#### 초기 피그마 DB 스펙

* 2020년까지만 해도, 피그마는 여전히 한대의 AWS RDS를 사용하고 있었다.
  * 피크 트래픽시에 CPU 사용률이 65%를 넘으면서 예상치 못한 DB 레이턴시가 발생
* 재발을 막기위해 몇가지 방법을 사용했다.
  * DB 인스턴스를 가장 큰걸로 업그레이드(r5.24xlarge)
  * read Replica를 몇대 추가
  * 새로운 유스케이스에 대해서는 새 DB를 사용
  * pgBouncer를 커넥션 풀러로 사용함으로써 커넥션이 늘어날때의 충격을 제한함
* 그렇지만 여전히 문제점이 존재했다.
  * DB 사용의 대부분은 읽기가 아닌 쓰기
  * 복제 지연에 민감한 몇몇 케이스로 인해 모든 읽기 연산을 레플리카로 이관할 수 없었음

[https://github.com/genier1/genier1.gitbook.io/assets/19471818/40306534-5cbd-4058-8934-26dec7fb47db](https://github.com/genier1/genier1.gitbook.io/assets/19471818/40306534-5cbd-4058-8934-26dec7fb47db)

#### 수직 파티셔닝

* Figma에서는 위에서 언급한 문제를 해결하면서도 피그마 사용에는 문제가 없도록 하기 위해 수직 파티셔닝을 선택했다.
* Figma Files, Organization과 같이 트래픽이 많고 관련성이 높은 테이블을 다른 DB로 옮기면서 DB 부하가 많이 완화되었다.
* 파티셔닝할 테이블을 선정할때 피그마는 두가지를 우선적으로 고려함.
  * workload에 상당한 부분을 차지하는 테이블을 옮긴다.
    * 이를 측정하기 위해 average active sessions (AAS) for queries라는 지표를 사용함
    * 특정 시점에 주어진 쿼리를 처리하는 평균 활성 스레드 수
  * 옮겨지는 테이블은 다른 테이블과 강한 연관성이 없어야 한다.
    * Ruby ORM인 ActiveRecord에 연결되는 런타임 유효성 검사기를 사용
* 파티셔닝할 테이블이 선정되면 다운타임 없이 마이그레이션 해야한다. 따라서, 피그마 팀은 몇가지 목표를 정했다.
  * 가용성에 손상이 가는 시간은 1분 이내
  * 쉽게 반복할 수 있도록 하기 위한 자동화
  * 최근 파티션을 취소할 수 있는 기능
* 아래와 같은 절차로 파티셔닝을 진행했다.
  1. 어플리케이션이 여러 파티션에 쿼리할 수 있도록 준비
  2. 복제 지연이 0에 가까울때까지 새 DB로 테이블을 복제
  3. 원본 데이터 일시 중지
  4. DB가 동기화 될 때까지 대기
  5. 쿼리 트래픽을 새 DB로 라우팅
  6. 활동 재개

#### 논리적 복제 수행

* DB 복제와 관련해 Postgres에서 스트리밍 복제 또는 논리적 복제 옵션 중 하나를 선택할 수 있었으나, 논리적 복제를 선택하였음
  * 논리적 복제를 통해 대상 데이터베이스의 저장 공간을 훨씬 적게 사용하면서 테이블의 일부를 이식할 수 있었다.
  * 다른 Postgres Major 버전에서 실행 중인 데이터베이스에 데이터를 복제할 수 있음
  * 필요한 경우 역방향 복제를 설정하여 작업을 롤백할 수 있음
* 그러나 논리적 복제는 속도가 매우 느리다는 문제가 있었음
  * Postgres가 대상 데이터베이스에서 인덱스를 유지 관리하는 방식으로 인한 이슈
  * 복제 프로세스는 대량의 행을 복사하는 동시에 한 번에 하나의 행씩 인덱스를 업데이트한다.
  * Figma 팀은 인덱스를 제거한 후 데이터를 복제하고 복제 후 다시 인덱스를 추가함으로써 복제 시간을 몇시간 정도로 단축함

#### 수평 스케일링

* Figma의 사용자 기반과 기능 세트가 증가함에 따라 수직 파티셔닝이 한계에 가까워지고 있었음.
* 일부 테이블에는 테라바이트 단위의 데이터와 수십억 개의 행이 포함되어 있어서 단일 DB에 보관하기에는 너무 데이커가 컸음
* 특히 아래 두가지 이슈가 문제였다.
  * Postgres Vacuum 이슈
    * Vacuum은 Postgres에서 삭제되거나 쓸모없는 행이 차지하는 저장 공간을 회수하는 백그라운드 프로세스이다.
    * 그러나 대형 테이블을 Vacuum하는 것은 리소스를 많이 소모하고 성능 문제와 가동 중지를 일으킬 수 있다.
  * 초당 최대 IO 작업 수
    * Amazon RDS의 최대 IOPS 한도를 곧 초과할 것으로 보였음
* 큰 테이블을 여러 물리적 데이터베이스에 분산시키는 샤딩을 통해 확장을 시도함.
* 그러나 샤딩시에 발생하는 문제들을 고려해야 함
  * 일부 SQL 쿼리에서 비효율 발생
  * 애플리케이션 코드를 업데이트하여 쿼리를 올바른 샤드로 효율적으로 라우팅해야 함.
  * 스키마 변경시 모든 샤드에 적용되어야 함
  * Postgres에서 더 이상 외래 키와 전역적으로 고유한 인덱스를 적용할 수 없다.
  * 트랜잭션 적용시 여러 샤드에 걸치게 되므로 Postgres를 사용하여 트랜잭션을 적용할 수 없다.

#### 샤딩 구현

* Figma 팀은 CockroachDB, TiDB, Spanner, Vitess와 같은 대체 SQL 옵션과 NoSQL 데이터베이스를 조사했다.
* 그러나 여러 이유로 인해 기존의 수직 분할된 RDS Postgres 인프라 위에 샤딩 솔루션을 구축하기로 결정
  * 수년간 안정적으로 운영해 온 RDS Postgres에 대한 기존의 전문 지식을 활용할 수 있음
  * Figma의 특정 요구사항에 맞춰 솔루션을 맞춤화할 수 있다.
  * 문제가 발생할 경우 샤딩되지 않은 Postgres 데이터베이스로 쉽게 롤백 가능
  * Postgres 아키텍처 위에 구축된 복잡한 관계형 데이터 모델을 NoSQL과 같은 새로운 접근 방식으로 변경할 필요가 없음
* Figma는 "colos" 또는 공동 배치(colocations)라는 개념을 도입했다.
  * 동일한 샤딩 키와 물리적 샤딩 레이아웃을 공유하는 관련 테이블의 그룹
  * colos를 생성하기 위해 그들은 UserId, FileId 또는 OrgID와 같은 몇 가지 샤딩 키를 선택하였음.

#### 논리적 샤딩 vs 물리적 샤딩

* Figma는 애플리케이션 계층에서의 "논리적 샤딩"과 Postgres 계층에서의 "물리적 샤딩"의 개념을 분리했다.
* 논리적 샤딩은 각 테이블에 대해 여러 개의 뷰를 생성하는 것을 포함하며, 각 뷰는 주어진 샤드의 데이터 하위 집합에 해당한다.
  * 테이블에 대한 모든 읽기 및 쓰기는 이러한 뷰를 통해 전송되므로 데이터가 물리적으로 단일 데이터베이스 호스트에 위치해 있더라도 테이블이 수평으로 샤딩된 것처럼 보인다.
* Figma에서는 위험이 더 큰 분산 물리적 샤딩을 실행하기 전에 더 안전하고 위험이 적은 논리적 샤딩 롤아웃을 수행할 수 있었다.
  * 논리적 샤딩을 롤백하는 것은 간단한 구성 변경이었지만, 물리적 샤드 작업을 롤백하려면 데이터 일관성을 보장하기 위해 더 복잡한 조정이 필요하다.

#### DBProxy 쿼리 엔진

* 수평 샤딩을 지원하기 위해 Figma 엔지니어링 팀은 애플리케이션과 PGBouncer와 같은 연결 풀링 계층 사이에 위치하는 DBProxy라는 새로운 서비스를 구축했다.
* DBProxy에는 샤딩된 쿼리를 파싱하고 실행할 수 있는 경량 쿼리 엔진이 포함되어 있으며, 아래의 세 가지 주요 요소로 구성되었다.(아래 그림 참조)
  * 애플리케이션에서 전송한 SQL을 읽고 추상 구문 트리(AST)로 변환하는 쿼리 파서.
  * AST를 파싱하고 쿼리 유형(삽입, 업데이트 등)과 논리 샤드 ID를 쿼리 계획에서 추출하는 논리 플래너.
  * 쿼리를 논리 샤드 ID에서 물리적 데이터베이스에 매핑하고 적절한 물리적 샤드에서 실행할 수 있도록 쿼리를 다시 작성하는 물리적 플래너.

{% embed url="https://github.com/genier1/genier1.gitbook.io/assets/19471818/f6a4e3fc-9208-4b35-b522-a283cbf79d6d" %}

* 수평 샤딩에서 쿼리와 관련한 트레이드-오프가 존재한다. (아래 그림 참조)
  * 단일 샤드 키에 대한 쿼리는 구현하기가 상대적으로 쉽다. 쿼리 엔진은 샤드 키를 통해 적절한 DB로 쿼리를 라우팅하면 된다.
  * 그러나 쿼리에 샤딩 키가 포함되어 있지 않으면 쿼리 엔진은 더 복잡한 작업을 수행해야 한다.
    * 모든 샤드에 쿼리를 보내고 각 샤드의 응답을 모아야 한다.
    * 이로 인해 데이터베이스 부하가 증가할 수 있다.
  * DBProxy는 부하 제한, 트랜잭션 지원, 데이터베이스 토폴로지 관리 등을 통해 이 부분을 관리한다.

{% embed url="https://github.com/genier1/genier1.gitbook.io/assets/19471818/b212e773-1457-436f-bf46-65f433a0efbd" %}

#### 해결해야할 과제들

* Figma의 인프라 팀은 2023년 9월에 첫 번째 수평 샤딩된 테이블을 배포했다.
* 해당 작업은 가용성에 미치는 영향을 최소화하면서 성공적으로 이뤄졌다. 또한 샤딩 작업 후 지연 시간 증가하거나 가용성이 낮아지지 않았다.
* Figma의 궁극적인 목표는 데이터베이스의 모든 테이블을 수평으로 샤딩하고 거의 무한한 확장성을 달성하려고 하지만, 아직 해결해야할 과제들이 있다.
  * 수평 샤딩된 스키마 업데이트 지원
  * 수평 샤딩된 기본 키에 대해 전역적으로 고유한 ID 생성
  * 비즈니스에 중요한 유즈케이스를 위한 원자적 크로스-샤드 트랜잭션 구현
  * 분산 전역 고유 인덱스 활성화
  * 개발자 속도를 향상시키기 위한 ORM 모델 개발
  * 버튼 클릭으로 샤드 분할을 가능하게 하는 자동 리샤드 작업
