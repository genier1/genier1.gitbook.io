# 4장. 실용주의 편집증

#### 계약에 의한 설계

* 계약에 의한 설계는 단순하지만 강력한 기법이다.
  * 프로그램의 정확성을 보장하기 위해 모듈의 권리와 책임을 문서화하고 합의하는 데에 초점을 맞춘다.
  * 선행조건
    * 함수의 요구 사항, 선행조건이 위반된 경우에는 함수가 호출되어서는 안된다.
    * 예) 입금함수에서 입금액은 0보다 크다. 계좌가 개설되어 있어야 한다 등등
  * 후행조건
    * 함수가 수행할 것이라고 보장하는 것. 이는 함수가 결국 종료될 것이라는걸 의미한다.
    * 예) 함수가 새로운 거래를 반환한다.
  * 클래스 불변식(상태)
    * 호출자의 입장에서 이 조건이 언제나 참인 것을 클래스가 보장한다.
* DBC와 TDD의 차이
  * DBC는 테스트 환경 구성이나 Mock이 불필요하다.
  * 테스트 하나에 한가지 경우만 다루는 반면, DBC는 모든 입력값에 대해 성공/실패를 정의한다.
  * TDD는 빌드 과정 중 테스트시만 수행된다. 하지만 DBC와 단정문은 영원하며 빌드 과정 전체에서 사용된다.
* DBC와 일찍 멈추기
  * 단정문이나 DBC 방식을 통해 선행/후행 조건, 불변식을 검증하면 더 일찍 멈추고 문제에 대해 보다 정확한 정보를 알려줄 수 있다.
  * 문제를 찾고 원인을 밝히기 위해서는 사고가 난 지점에서 일찍 멈추는 것이 좋다.
* 의미론적 불변식
  * 의미론적 불변식은 무언가가 품은 진짜 의미의 중심이어야 하며, 일시적인 정책에 영향받으면 안된다.
  * 불변식의 자격이 있는 요구 사항을 찾았다면 모든 문서에 잘 드러나도록 만들어라.

#### 죽은 프로그램은 거짓말 하지 않는다.

* 모든 예외를 catch로 잡은 후 로그 메시지를 찍고 다시 예외를 발생시키지 마라
  * 애플리케이션 코드가 오류 처리 코드 사이에 묻혀버린다.
  * 예외가 추가되면 코드를 수정해야 한다.
* 망치지 말고 멈춰라
  * 얼랭과 엘릭서는 이 철학을 수용했다.
    * 슈퍼바이저를 통해 관리하며 이 기법은 매우 효과적이어서 고가용성, 결함 감내 시스템에서 얼랭,엘릭서를 채택하는 요인이다.
* 어떤 환경에서는 프로그램을 그냥 종료하는 것이 적절하지 않을수도 있다.
  * 해제되지 않은 리소스, 로그 메시지 기록, 트랜잭션 정리등
  * 그러나 최대한 빨리 종료해라.
* 일반적으로 죽은 프로그램이 끼치는 피해는 이상한 상태의 프로그램이 끼치는 피해보다 훨씬 적다.

#### 단정적 프로그래밍

* 단정문으로 불가능한 상황을 예방하라
  * 물론 그런일은 절대 일어나지 않을거야 라고 생각이 든다면 이를 확인하는 코드를 추가하라.
* 하지만 진짜 오류 처리를 해야 하는 곳에 단정을 대신 사용하지는 말라
  * 단정은 결코 일어나면 안 되는 것들을 검사하는 것이다.
* 부작용을 주의하라
  * 디버깅 행위가 디버깅하려는 시스템의 행동을 바꾸는 문제를 주의하라.
  * 예) assert (iter.nextElement() ≠ null)
    * nextElement() 호출은 다음 원소로 iterator를 이동시키는 부작용이 있다.

#### 리소스 사용의 균형

* 자신이 시작한 것은 자신이 끝내라.
  * 리소스를 할당하는 함수나 객체가 리소스를 해제하는 책임까지 져야 한다.
* 리소스를 할당한 순서의 역순으로 해제하라.
  * 이렇게 해야 한 리소스가 다른 리소를 참조하는 경우에도 참조를 망가트리지 않는다.
* 코드의 여러 곳에서 동일한 구성의 리소스를 할당하는 경우에는 언제나 같은 순서로 할당해야 deadlock 가능성을 줄일 수 있다.
  * 프로세스 A가 resource1을 확보한 상태에서 resource2를 획득하려고 하고 있는데, 프로세스 B가 resource2를 확보한 상태에서 resource1을 요청하려고 한다면 문제가 발생할 것이다.
* 균형을 점검하기
  * 래퍼를 사용해서 상태가 올바른지 점검하라.
  * 리소스 사용량이나 메모리 릭을 점검하는 것도 유용하다.

#### 헤드라이트를 앞서가지 마라

* 미래를 과하게 예측하지 마라. 대신, 작은 단계들을 밟아나가라.
  * 더 진행하기 전에 피드백을 받아라.
  * 피드백 예) REPL, 단위 테스트, 사용자 데모 등등
* 미래를 예측하되, 볼 수 있는 미래까지만 고려하라
  * 불확실한 미래에 대비해 설계하는 대신, 언제나 교체 가능한 코드를 작성해서 대비하라.
