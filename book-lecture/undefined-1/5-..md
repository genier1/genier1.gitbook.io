# 5장. 복제

#### 복제

* 지연시간 감소, 가용성 증가, 읽기처리량 증가를 위해 복제를 하는 경우들이 생김
* 단일리더, 다중 리더, 리더없는 복제의 종류가 있음

#### 리더와 팔로워

* DB의 모든 쓰기는 모든 복제 서버에서 처리되어야 함
  * 리더기반 복제(능동/수동 또는 마스터/슬레이브)
  * 쓰기요청은 리더에 기록되며, 복제로그나 변경스트림을 통해 팔로워에게 전송
* 동기식 vs 비동기식 복제
  * 동기식 복제
    * 장점- 리더와 팔로워가 일관성 있게 최신 데이터 복사본을 가지는 것을 보장, 리더가 갑자기 작동하지 않아도 팔로워의 데이터를 사용할수 있음을 확신
    * 단점 - 동기 팔로워가 응답하지 않으면 쓰기가 처리되지 않음
  * 모든 팔로워가 동기식인 상황은 비현실적이며 보통 하나는 동기, 그 외에는 비동기로 처리 → 이를 반동기식이라고 함
  * 리더기반 복제는 보통 완전 비동기식으로 구성
    * 장점 모든 팔로워가 잘못되도 리더가 쓰기 처리 지속 가능
    * 단점 - 리더가 잘못되고 복구할수 없으면 팔로워에 복제되지 않은 모든 쓰기는 유실
* 새로운 팔로워 설정
  * 리더 DB 스냅샷을 일정 시점에 가져옴 → 스냅샷을 새로운 팔로워에 복사 → 팔로워를 리더에 연결해 스냅샷 이후 모든 데이터 변경을 요청(MySQL에서는 binlog coordinate를 통해 처리)

#### 노드 중단 처리

* 팔로워 장애
  * 보관된 로그의 결함 발생 직전 마지막 트랜잭션을 알아낸 후 리더에 연결해 이후 데이터 변경을 모두 요청
* 리더 장애(failover)
  * 리더가 장애인지 판단 - 대부분은 타임아웃으로 판단
  * 새로운 리더 선출 - 보통 이전 리더의 최신 데이터 변경사항을 가진 복제서버
  * 새로운 리더 사용을 위한 시스템 재설정
* 잘못될수 있는 점
  * 비동기식 복제 사용시 새로운 리더는 이전 리더의 쓰기를 일부 수신하지 못할 수 있음. 가장 일반적인 해결책은 이전 리더의 복제되지 않은 쓰기를 단순히 폐기함. but 내구성 약화
  * 쓰기 폐기는 DB 외부의 다른 저장소가 DB 내용에 맞춰 조정되어야 한다면 특히 위험함
  * 특정 시나리오에서 두 노드가 모두 자신이 리더라고 믿을수 있음(스플릿 브레인)
  * 리더가 죽었다고 판단할 적절한 타임아웃은??
* 쉬운 해결책은 없음. 일부 운영팀은 수동 장애 복구를 선호함

#### 복제 로그 구현

* 구문 기반 복제
  * MySQL에서는 구문기반 복제 대신 로우기반 복제를 사용함
  * 모든 구문을 팔로워에게 전달. 팔로워는 SQL 구문을 파싱하고 실행
  * 문제점
    * NOW()나 RAND() 같은 구문이 있다면 복제 서버마다 다른 값을 생성함
    * 자동증가 칼럼을 사용하거나 DB 데이터에 의존한다면 정확히 같은 순서로 실행하지 않을 경우 결과가 달라질 수 있음
    * 부수 효과를 가진 구문(트리거, 프로시저)은 복제 서버마다 다른 부수효과가 나타날 수 있음
* 쓰기전 로그 전달
  * PostgreSQL, 오라클등에서 사용
  * 추가 전용 로그를 전달 → 리더와 정확히 동일한 데이터 구조의 복제본이 만들어짐
  * 로그가 제일 저수준의 데이터를 기술함(어떤 디스크 블록에서 어떤 바이트를 변경했는지 등) → 복제가 저장소 엔진과 밀접하게 엮인다는 단점이 있음
* 논리적(로우 기반)로그 복제
  * 복제와 저장소엔진 로그를 다른 형식으로 사용
  * 대개 로우 단위로 DB 테이블에 쓰기를 기술한 레코드 열
  * 하위 호환성을 쉽게 유지할 수 있고 리더와 팔로워가 다른 저장소 엔진을 실행할수도 있음
  * 외부 애플리케이션이 파싱하기 더 쉬움, CDC를 통해 외부 시스템에 전송시 유용함
* 트리거 기반 복제
  * 많은 DB에서 사용할수 있는 기능인 트리거나 스토어드 프로시저를 이용
  * 유연성이 높은 장점이 있음

#### 복제 지연 문제

* 애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 지난 정보를 볼 수 있음 → 최종적 일관성이 깨짐
* 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터가 복제 서버에 아직 반영되지 않았을 수 있음
  * 쓰기 후 읽기 일관성(자신의 쓰기 읽기 일관성)이 필요함
  * 해결 방법
    * 사용자가 수정한 내용을 읽을 때는 리더에서 읽고, 그 외에는 팔로워에서 읽음
      * 단, 대부분의 내용을 사용자가 편집할 수 있다면 비효율적임
    * 클라이언트는 가장 최근 쓰기의 타임스탬프를 기억할 수 있음. 복제서버가 아직 최신이 아닌 경우 다른 복제서버가 읽기를 처리하거나 복제서버가 따라잡을때까지 질의를 대기 시킬 수있음
    * 복제 서버가 여러 데이터센터에 있다면 복잡도가 증가함 - 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅 되어야 함
  * 동일한 사용자가 여러 디바이스를 사용할 떄 문제 발생
    * 디바이스간 쓰기 후 읽기 일관성이 제공되어야 함
      * 사용자의 마지막 갱신 타임스탬프를 기억하는 방식은 어려움
* 단조 읽기
  * 시간이 거꾸로 흐르는 현상을 방지
  * 강한 일관성보다는 약하지만 최종적 일관성보다는 강한 보장
  * 각 사용자의 읽기가 항상 동일한 복제서버에서 수행됨
* 인과성 순서 위반
  * 일관된 순서로 읽기가 보장되어야 함
  * 파티셔닝(샤딩) DB에서 발생하는 문제 - 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서가 없음
  * 서로 인과성이 있는 쓰기는 동일 파티션에 기록하게 함 - 일부 앱에서는 효율적이지 않음

#### 다중 리더 복제

* TODO

#### 리더 없는 복제

* TODO
