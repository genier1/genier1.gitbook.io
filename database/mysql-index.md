# MYSQL Index 정리

#### 인덱스란

* 책의 색인과 유사한 기능
* 저장 성능을 희생하는 대신, 읽기 속도를 높이는 기능이다.
  * 대부분의 서비스에서는 읽기:쓰기 비율이 9:1 \~ 8:2이다.
* 인덱스를 설정하면 추가적인 저장공간이 발생한다.

#### 인덱스 분류 방식

* 역할
  * Primary Key
  * Secondary Key
* 데이터 저장 방식
  * B-Tree
  * Hash
  * 기타(Fractal-Tree, Merge-Tree 등등)
* 데이터의 중복 허용 여부
  * Unique
  * Non-Unique

#### B-Tree 인덱스

{% embed url="https://github-production-user-asset-6210df.s3.amazonaws.com/19471818/325033855-5a3ffa8e-17ba-47d6-aaba-50e7675708c5.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA/20240424/us-east-1/s3/aws4_request&X-Amz-Date=20240424T230709Z&X-Amz-Expires=300&X-Amz-Signature=cfd765bc4461d4c68609c9b9f4290ee91c386bda88b5c734b8266f88693ca644&X-Amz-SignedHeaders=host&actor_id=19471818&key_id=0&repo_id=783676058" %}
Real My SQL 8.0 1권 참조
{% endembed %}

* DB의 인덱싱 알고리즘 중 가장 일반적으로 사용되는 알고리즘이다.
* 칼럼의 원래 값을 변형시키지 않고, 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
* 루트 노드 - 브랜치 노드 - 리프 노드로 구성되며, 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.
* 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되지 않고 임의의 순서로 저장되어 있다.
* InnoDB의 경우, 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다. (아래 스크린샷 참조)
  * 따라서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다.
  * 인덱스에 저장되어 있는 PK 값을 이용해 PK 인덱스를 한 번 더 검색한 후, PK 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다.
* 인덱스 추가시 작업비용은 대략 1.5배 정도로 예측할 수 있다.
  * 인덱스가 3개 일 경우 5.5정도의 비용으로 추산 가능 (1.5 \* 3 + 1)
  * 대부분 디스크로부터 인덱스 페이지 읽기/쓰기를 하는데 소요

{% embed url="https://github-production-user-asset-6210df.s3.amazonaws.com/19471818/325035389-d0ccd136-c499-4ee2-a1e1-ae08360c6c77.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA/20240424/us-east-1/s3/aws4_request&X-Amz-Date=20240424T230743Z&X-Amz-Expires=300&X-Amz-Signature=ed321727af13c9a319410b1bbac66ba2c005ae4e1c926673d8ceb3e65106fa53&X-Amz-SignedHeaders=host&actor_id=19471818&key_id=0&repo_id=783676058" %}
Real My SQL 8.0 1권 참조
{% endembed %}

#### Primary Key Index(Clustering Index)

* PK로 만들어진 인덱스
* NOT NULL이며 중복을 허용하지 않음
* InnoDB에서는 PK 값을 기준으로 페이지
* 장점
  * PK로 검색할 때 처리 성능이 매우 빠름. 특히 PK를 범위 검색하는 경우 매우 빠름
  * 테이블의 모든 세컨더리 인덱스가 PK를 갖고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)
* 단점
  * 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 키값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
  * 세컨더리 인덱스를 통해 PK로 다시 한번 검색해야 하므로 처리 성능이 느림
  * INSERT 시에 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림

#### PK는 반드시 명시할 것

* PK는 AUTO-INCREMENT보다는 업무적으로 생성하는 것이 좋음
* PK가 없다면 AUTO-INCREMENT 칼럼을 이용해서라도 PK를 생성하는 것을 권장
* InnoDB 기준, PK가 없는 경우에는 다음 우선순위대로 PK를 대체할 칼럼을 선택함
  1. PK가 있으면 기본적으로 PK를 클러스터링 키로 선택
  2. NOT NULL 옵션의 유니크 인덱스 중 첫번째 인덱스를 클러스터링 키로 선택
  3. 자동으로 유니크한 값을 가지도록 증가하는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택
* 3번 처럼 InnoDB가 자동으로 추가한 PK는 사용자에게 노출되지 않으며, 쿼리 문장에서 명시적으로 사용할 수 없다.
  * 즉, 아무 의미 없는 값으로 클러스터링되는 것이며, 사용자에게 아무 혜택도 주지 못한다.

#### Secondary Index

* PK를 제외한 나머지 모든 인덱스
* Secondary 인덱스는 데이터의 주소가 아닌 PK를 가지고 있다.
  * 따라서 Secondary Index로 조회시 PK를 통한 데이터 조회 절차가 추가되지만 성능 상 큰 문제는 없다.
  * PK값이 아닌 주소를 가지게 될 경우, PK 변경시 해당 데이터의 주소가 변경된다.
    * 이 경우, 해당 주소를 갖고 있는 Secondary Key를 모두 업데이트 해주어야 하는 문제가 발생한다.

#### Unique Index

* 테이블에 같은 값이 2개 이상 저장될 수 없음을 의미.
  * MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.
* NULL도 저장될 수 있으며, NULL은 특정 값이 아니므로 2개 이상 저장될 수 있음

#### 유니크 인덱스와 세컨더리 인덱스 비교

* 읽기 시 성능 - 비슷함
  * 유니크 하지 않은 세컨더리 인덱스에서는 레코드를 한 건 더 읽어야 하므로 느리다고 생각할 수 있으나, CPU에서 하는 작업이므로 성능상 영향이 거의 없음
* 쓰기 시 성능 - 유니크 인덱스가 조금 더 느림
  * 유니크 인덱스 키 값을 쓸 때 중복여부를 체크함
  * 유니크 인덱스 중복여부 체크 시 읽기 잠금을 사용하고, 쓰기 시에는 쓰기 잠금을 사용함
    * 이 과정에서 데드락이 빈번하게 사용할 수 있음
  * InnoDB 스토리지 엔진에서는 인덱스 키의 저장을 버퍼링 하기 위해 체인지 버퍼를 사용.
    * 이로 인해 인덱스 저장,변경 작업이 빠르게 처리되지만, 유니크 인덱스는 중복체크로 인해 작업 자체를 버퍼링하지 못함

#### 외래키(Foreign Key)

* InnoDB에서만 외래키를 생성할 수 있다.
* 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.
  * 외래키가 제거되지 않은 상태에서는 해당 인덱스를 삭제할 수 없다.
* 외래키에 대한 변경시 잠금 경합이 발생할 수 있고 연관 테이블에 읽기 잠금이 걸릴 수 있다.
  * 전체적으로 쿼리의 동시 처리에 영향을 미칠 수 있으니 주의해야 한다.

#### 참고 링크

* [Real MySQL 8.0](https://www.yes24.com/Product/Goods/103415627)
* [B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/286)
