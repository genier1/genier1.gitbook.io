# 3장. 저장소와 검색

* 많은 DB는 추가전용 로그를 사용함
* 그러나 로그에서 조회할 경우 검색 비용이 O(n)임 - 색인 필요
* 색인은 기본 데이터에서 파생된 추가적인 구조
  * 내용에는 영향을 미치지 않으나, 쓰기 과정에서 오버헤드 발생

#### 해시 색인

* 보통 해시맵으로 구현
* 파일에 항상 추가만 한다면 디스크 공간이 부족해짐
  * 특정 크기의 세그먼트로 로그를 나눈 후 세그먼트 파일들에 대해 주기적으로 컴팩션을 수행
  * 주요 고려사항
    * 파일 형식 - csv보다는 바이너리 형식을 사용하는게 빠르고 간단
    * 키와 관련된 값을 삭제하려면 특수한 삭제 레코드(툼스톤)를 추가해야함
    * 고장 복구 - DB 재시작시 인메모리 해시맵은 손실됨
      * 전체 세그먼트 파일을 읽고 복구하는건 시간이 오래걸림. 스냅샷을 디스크에 저장해 복구속도를 높일 수 있음
    * 로그에 레코드를 추가하는 도중에도 죽을수 있음 - 로그의 손상된 부분을 탐지해 무시해야함
    * 동시성 제어 - 하나의 쓰기 스레드만 사용
* 추가전용로그를 사용하는 이유
  * 순차적 쓰기임으로 무작위 쓰기보다 훨씬 빠르다
  * 추가전용이며 불변이면 덮어쓰지 않으므로 고장복구나 동시성처리가 쉬움
  * 세그먼트 병합은 조각화되는 파일 문제 피함
* 해시테이블 단점
  * 메모리에 저장하므로 키가 너무 많으면 문제가 됨
  * 디스크에 저장하는건 무작위 I/O가 많이 필요하고 확장비용이 비싸며 해시충돌 해소 로직 필요.
  * 해시테이블은 범위질의에 효율적이지 않음

#### SS테이블과 LSM 트리

* 세그먼트 파일의 키,값 쌍을 키로 정렬함 - Sorted String Table, 줄여서 SS테이블이라고 함
* 장점
  * 파일이 사용가능한 메모리보다 크더라도 간단하고 효율적임. 병합정렬과 비슷
  * 특정 키를 찾기위해 메모리에 모든 키의 색인을 유지할 필요X
  * 요청범위내의 레코드를 압축함 - 디스크 공간 절약, I/O 대역폭 사용 감소
* SS테이블 유지
  * 레드블랙트리와 같은 트리구조를 사용해 메모리에 유지
  * 쓰기가 들어오면 인메모리 균형 트리(memtable)에 추가
  * 멤테이블이 커지면 SS테이블 파일로 디스크에 기록
  * 읽기 요청 시 멤테이블에서 탐색 한 후, 디스크에서 확인
  * 가끔 백그라운드에서 세그먼트 파일 컴팩션 수행
* 성능 최적화
  * LSM트리 알고리즘은 DB에 존재하지 않는 키를 찾는 경우 느릴수 있음 - 블룸필터 사용
  * SS테이블 압축 전략
    * 사이즈 계층
      * 상대적으로 더 새롭고 작은 SS테이블을 큰 SS테이블에 연이어 병합
    * 레벨 컴팩션
      * 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동 - 디스크 공간 덜 사용
  * LSM트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 병합하는 것. - 디스크 쓰기를 순차적으로 하기 때문에 높은 쓰기 처리량 보장

#### B트리

* 1970년대 등장 후 보편적인 색인구조로 자리잡음
* SS테이블과 같이 정렬된 키-값 쌍을 유지하므로 키-값 검색과 범위질의에 효율적
* LSM트리는 일반적으로 수 메가 이상의 세그먼트로 나누고 항상 순차적으로 세그먼트를 기록하지만, B트리는 전통적으로 4kb 크기의 고정 크기 블록이나 페이지로 나누고 한번에 하나의 페이지에 읽기/쓰기 작업을 진행함
  * 디스크가 고정 크기 블록으로 배열되므로 이런 설계는 하드웨어와 조금 더 밀접한 관련이 있음
* 각 페이지는 주소와 위치를 이용해 식별함. 루트부터 시작해 개별 키를 포함하는 리프 페이지에 도달. B트리의 분기계수가 4만 되어도 256TB까지 저장 가능
* B 트리의 키 값을 갱신하려면 리프페이지를 검색 한 후 페이지의 값을 변경하고 디스크에 다시 기록함. 만약 여유공간이 없다면 페이지 하나를 반쯤 채워진 둘로 나눈다. 트리가 계속 균형을 유지함
* DB가 고장 상황에서 스스로 복구하려면 디스크 상에 쓰기전 로그(WAL 또는 redo log)라는 데이터를 추가해서 구현한다.
* 같은 자리의 페이지를 갱신할 때 동시성 제어를 해야함
  * 보통 래치(가벼운 잠금)로 데이터 구조를 보호
* B트리 최적화 기법
  * 일부 DB는 WAL 대신 쓰기 시 복사 방식을 사용함. - 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 함
  * 페이지에 키를 축약해 써서 공간을 절약하고 분기 계수를 낮춤
  * 많은 B트리 구현은 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도함
  * 트리에 포인터를 추가해 상위 페이지를 다시 참조하지 않고 키를 순서대로 스캔함 - 예를 들어, 각 리프페이지가 양쪽 형제페이지에 대한 참조를 가짐
  * 프랙탈 트리 → 디스크 찾기를 줄이기 위해 로그 구조화 개념을 일부 차용
* B트리 vs LSM 트리
  * LSM 트리는 보통 쓰기에서 빠르고, B트리는 읽기에서 빠르다.
    * LSM 트리에서 읽기 시에 각 컴팩션 단계에 있는 여러 데이터 구조와 SS 테이블을 확인해야 하기 때문
  * LSM 트리 장점
    * B트리 색인은 모든 데이터를 최소 두번 기록 해야함 - WAL 한번, 페이지에 한번
    * 해당 페이지 내 몇바이트만 바뀌어도 한번에 전체페이지를 기록하는 오버헤드 있음
    * LSM 또한 SS 테이블의 반복된 컴팩션과 병합으로 인해 데이터를 여러번 다시 씀 → 쓰기 증폭 발생, 특히 SSD는 블록 덮어쓰기 횟수 제한이 있음
    * 쓰기 시 많은 성능 병목은 디스크에 쓰는 속도이며 쓰기 증폭은 성능 비용이다. → 디스크에 기록할 수록 초당 쓰기 처리량이 줄어듬
    * LSM 트리는 B트리에 비해 쓰기 처리량 높게 유지 가능 → 쓰기 증폭이 낮고, 순차적으로 컴팩션된 SS테이블 때문
    * 보통 B트리에 비해 디스크에 더 적은파일을 생성하므로 압축률도 더 좋다. 레벨컴팩션 사용시 압축률이 더 좋음
  * LSM 트리 단점
    * 컴팩션 과정이 진행중인 읽기/쓰기 성능에 영향을 줌
    * 쓰기 처리량이 높을때 컴팩션 설정을 잘못하면 컴팩션이 유입 쓰기 속도를 못따라감
    * B트리는 각 키가 색인의 한곳에만 정확하게 존재함, 반면 LSM은 다른 세그먼트에 같은키의 다중 복사본이 존재할 수 있음 → 트랜잭션 시맨틱을 제공하는 DB에는 B트리가 훨씬 매력적임
    * B트리는 많은 작업부하에 지속적으로 좋은 성능을 제공

#### 기타 색인 구조

* 관계형 DB에서는 보조 색인도 많이 사용.
  * 기본키와 달리 키가 고유하지 않음
* 키-값 색인시 값에 row 값을 저장하거나 row의 참조를 저장할 수 있음
  * row의 참조를 저장하는 경우 힙파일에 특정 순서 없이 저장
  * 힙파일 접근 방식이 일반적이며 키 변경 없이 값을 갱신할때 효율적이다.
  * 새로운 값이 많은 공간을 필요로 할 경우 힙에서 충분한 공간이 있는 곳으로 위치를 이동해야 하므로 모든 색인이 레코드의 새로운 힙 위치를 가리키게끔 갱신하거나, 이전 힙위치에 전방향 포인터를 두어야 함
  * 어떤 상황에서는 색인에 row를 저장함 → 클러스터드 색인
    * mySQL의 InnoDB에서는 테이블의 기본키가 항상 클러스터드 색인이며, 보조 색인은 힙 파일이 아닌 기본키를 참조함
    * 커버링 인덱스 - 색인 안에 테이블의 칼럼 일부를 저장한다. 이러면 색인만 사용해서 일부 질의에 응답이 가능하다.
    * 클러스터드 색인과 커버링 인덱스는 읽기 성능을 높일수 있지만 추가적인 저장소가 필요하고 쓰기과정에서 오버헤드가 발생함. 애플리케이션에서 복제로 인한 불일치를 파악할수 없으므로 DB에서 트랜잭션 보장을 강화해야함
* 다중칼럼색인
  * 결합색인 - 하나의 칼럼에 다른 칼럼을 추가하는 방식
  * 다차원 색인 - 지리 공간 데이터에 유용하게 사용
    * 예시 - SELECT \* FROM map WHEHRE latitude > 51.4946 AND latitude < 51.5079 AND longitude > -0.1162
    * 일반적인 B 트리나 LSM 트리 인덱스는 이러한 질의에 효율적이지 않음
    * 이차원 위치를 공간 채움 곡선을 통해 단일 숫자로 변환한 후 B트리 인덱스를 사용할 수 있음
    * 또는R 트리처럼 전문 공간 색인을 사용
* 전문 검색, 퍼지 색인
  * 루씬은 용어 사전을 위해 작은 인메모리 인덱스를 이용해 SS테이블과 같은 구조를 사용
  * 인메모리 색인은 트라이와 유사하며 레벤슈타인 오토마톤으로 변환
* 인메모리 DB
  * 맴캐시드 같은 저장소는 장비 재시작시 손실을 허용하는 캐시용도로 사용됨
  * 다른 인메모리 DB는 지속성을 목표로 함
    * 특수 하드웨어를 사용하거나 디스크에 변경사항 로그 또는 주기적인 스냅샷을 기록하거나 다른 장비에 인메모리 상태 복제
    * 관계형모델의 인메모리DB도 있음
  * 인메모리 DB는 디스크 기반 인덱스로 구현하기 어려운 모델을 제공함
    * 레디스 - 우선순위 큐, 셋 등

#### 트랜잭션 분석

* 시간이 지나면서 커머셜 트랜잭션(OLAP) 뿐 아니라 온라인 트랜잭션(OLTP)도 필요해짐 → 데이터 분석 등
* 데이터 분석은 기존 트랜잭션과 접근 패턴이 매우 다름 → 데이터 웨어하우스를 통해 처리

#### 데이터 웨어하우스

* OLTP 작업에 영향을 주지 않고 분석가들이 마음껏 질의하는 개별 DB. ETL을 통해 적재
* 데이터 웨어하우스는 분석 접근 패턴에 맞게 최적화가 가능하다는 것
* 많은 데이터 웨어하우스는 별모양 스키마를 사용함
* 칼럼 지향 저장소
  * 데이터 웨어 하우스 질의는 보통 4\~5개 칼럼만 접근하므로 SELECT \* 형태의 질의를 사용하지 않음
  * 모든 값을 하나의 로우에 함께 저장하지 않고 각 칼럼별로 모든 값을 함께 저장함 → 작업량이 많이 줄어드는 장점
* 칼럼을 압축해서 디스크 처리량을 줄이기도 함 - 비트맵 부호화 등을 사용
  * 칼럼 고유 값은 로우 수에 비해 적음
* DW 질의는 디스크로부터 메모리를 가져오는 병목이 가장 큼
  * 벡터화 처리 - 칼럼 압축을 통해 L1 캐시에 더 많은 로우를 저장하고 비트 AND OR 연산자등은 압축된 칼럼 데이터를 바로 연산할 수 있음
