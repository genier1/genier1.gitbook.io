# 9장. 일관성과 합의

* 분산시스템에서는 많은 것이 실패할 수 있음 → 내결함성을 지녀야함
* 복제 DB는 최종적 일관성을 보장하지만, 언제 복제본이 수렴될지에 대해서는 보장하지 않음 → 매우 약한 보장

#### 선형성

* 최신성을 보장 → 읽힌 값이 가장 최근에 갱신된 값임을 보장함
* 기본 아이디어 - 시스템에 데이터 복사본이 하나인 것처럼 보이게 만듬
  * 읽기 요청은 가장 최신 값을 읽기 위해 반복적으로 DB를 폴링함
  * 연산 표시를 모은 선들은 항상 시간순이어야 하며, 결코 뒤로 가서는 안됨
* 선형성과 직렬성은 다른 개념임
  * 직렬성 - 트랜잭션들의 격리 속성
  * 선형성 - 레지스터(개별 객체)에 실행되는 읽기/쓰기에 대한 최신성 보장
* 선형성이 유용한 상황
  * 잠금과 리더 선출
    * 단일리더 복제를 사용하는 시스템은 리더가 여러개가 되면 안됨 → 잠금을 구현하는 방법을 사용할 경우 이 잠금은 반드시 선형적이어야 함
    * 주키퍼, etcd 등은 합의 알고리즘을 통해 선형성 연산을 내결함성이 있는 방식으로 구현함
  * 제약 조건과 유일성 보장
    * DB에 데이터 기록시 제약조건 강제는 선형성이 필요함
  * 채널간 타이밍 의존성
* 선형성 시스템 구현하기
  * 데이터 복사본 하나만 사용하면 해결되지만 내결함성이 없음
  * 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성 제공 X
* 선형성의 비용
  * 애플리케이션에서 선형성을 요구하고, 네트웍 문제로 인해 일부 복제서버가 다른 복제서버와 연결이 끊기면 해당 복제서버는 연결이 끊긴 동안 요청을 처리할 수 없음
  * 애플리케이션에서 선형성을 요구하지 않는다면, 연결이 끊기더라도 각 복제서버가 독립적으로 요청을 처리하는 방식으로 처리가 가능하지만 선형적이지 않음
* 실제로 선형적인 시스템은 매우 드물다. - 최신 다중코어 CPU의 램조차 선형적이지 않음 → 성능 때문에 선형성을 포기함

#### 순서화와 인과성

* 순서화는 인과성을 보존하는데 도움을 줌 → 시스템이 인과성에 의해 부과된 순서를 지키면 인과적으로 일관적이라고 함, 스냅샷 격리는 인과적 일관성을 제공함
* 단, 인과적 순서가 전체 순서는 아니며, 부분적으로 정해진 순서이다.
  * 선형성 시스템에서는 전체 순서를 정할 수 있음 - 따라서 선형성은 인과적 일관성보다 강하다.
* 모든 인과적 의존성을 실제로 추적하는건 실용성이 떨어짐
  * 일련번호, 타임스탬프를 통해 이벤트의 순서를 정할 수 있음
  * 타임스탬프는 논리적 시계에서 얻어도 됨
* 단일리더가 없다면 연산에 사용할 일련번호를 어떻게 만들까?
  * 각 노드별로 독립적인 일련번호 생성
  * 각 연산에 일 기준 시계에서 얻은 타임스탬프 붙이기
  * 일련번호 블록 할당
  * 그러나, 위 세가지 방식은 생성한 일련번호가 인과성에 일관적이지 않음
    * 각 노드는 초당 연산수가 다를 수 있음
    * 물리적 시계의 타임스탬프는 시계 스큐에 종속적이어서 인과성에 일관적이지 않을 수 있음
    * 일련번호 블록 할당의 경우 인과적으로 나중에 실행되는 연산이 앞 구간의 일련번호를 받을 수 있음
* 램포트 타임스탬프
  * 인과성에 비일관적이지만 인과성에 일관적인 일련번호 생성 → 분산시스템 분야에서 가장 많이 인용된 논문임
  * 각 노드는 고유 식별자를 갖고, 각 노드는 처리한 연산 개수를 카운터로 유지함 → (카운터, 노드 ID)의 쌍으로 관리
  * 카운터 값이 같으면 노드 ID가 큰것이 타임스탬프가 큼 → 전체 순서화 제공
  * 버전 벡터는 두 연산이 동시적인지 또는 어떤 연산이 다른 연산에 인과적으로 의존하는지 구분할 수 있지만, 램포트 타임스탬프는 항상 전체 순서화를 강제함
* 전체 순서 브로드캐스트
  * 램포트 타임스탬프가 해결하지 못하는 문제들
    * 예를 들어, 동일한 사용자 명칭을 막으려고 할때 특정 노드가 사용자명 생성 요청을 받고 당장 해당 요청의 성공/실패를 결정해야 하면 어려움
      * 다른 노드가 무엇을 하는지 확인해야하는데 다른 노드 중 하나에 장애가 생기거나 연결할 수 없다면 내결함성이 성립하지 않음
  * 전체순서 브로드캐스트는 두가지 속성을 항상 만족해야함
    * 신뢰성있는 전달 - 어떤 메시지도 손실 X
    * 전체 순서가 정해진 전달 - 모든 노드에 같은 순서로 전달
  * 주키퍼나 etcd는 전체 순서 브로드캐스트를 구현하고 있음
  * 전체순서 브로드캐스트는 메시지가 전달되는 시점에 그 순서가 고정됨 → 타임스탬프 순서화보다 강함
    * 로그를 만드는 방법 중 하나이다.
  * 펜싱토큰을 제공하는 잠금서비스를 구현하거나, 직렬성 트랜잭션을 구현하는데도 쓸 수 있음
  * 전체순서 브로드캐스트는 비동기식임
    * 언제 메시지가 전달될지는 보장X → 선형성 X
    * 그러나 전체순서 브로드캐스트를 기반으로 한 선형성 저장소를 만들 수 있음
      * 선형성 쓰기를 보장
      * 선형성 읽기는 보장하지 않음, 아래 방식을 사용하면 선형적 읽기 가능
        * 로그를 통해 순차 읽기
        * 로그에서 최신 로그 메시지 위치를 선형적 방법으로 얻을 수 있으면 이를 기다린 후 읽기 수행
        * 쓰기 실행시 동기적으로 갱신되어 최신을 보장하는 복제 서버에서 읽기
    * 선형성 저장소를 이용해 전체 순서 브로드캐스트 구현도 가능함

#### 분산 트랜잭션과 합의

* 노드가 동의하는 것이 중요한 상황들이 있음
  * 리더 선출, 원자적 커밋 등
* 2단계 커밋(2PC) 알고리즘
  * 아주 좋은 합의 알고리즘은 아님
  * 여러 노드에 걸친 원자적 트랜잭션을 달성하는 알고리즘 → 모든 노드가 커밋 또는 모든 노드가 어보트를 하도록 보장
  * 단일 노드 트랜잭션에서는 보통 존재하지 않는 새로운 컴포넌트인 코디네이터를 사용
  * 1단계 - 애플리케이션에서 커밋 준비가 되면 코디네이터에서 . 각노드에 준비요청을 보내서 커밋할수 있는지 확인
    * 2단계 - 모든 노드가 OK하면 모든 노드에 커밋요청을, 하나라도 아니오를 하면 모든 노드에 어보트 요청을 보냄
  * 준비요청과 커밋요청이 2단계의 요청에서 손실되지 않나???
    * 애플리케이션에서 분산트랜잭션 시작시 코디네이터에 트랜잭션ID 요청
    * 애플리케이션은 각 노드에 대해 단일 노드 트랜잭션을 추가하고 이 트랜잭션에 전역적으로 유일한 트랜잭션 ID를 붙임
    * 코디네이터에서 각 노드에 준비요청을 한후 그 응답에 대해 커밋할지 어보트할지 최종 결정을 함
    * 최종 결정을 디스크에 있는 트랜잭션 로그에 기록 → 커밋포인트라고 함
    * 최종 결정에 대해 각 노드에 요청을 전송하며, 이 요청이 실패하거나 타임아웃일 경우 무한히 재시도함
  * 2단계 커밋은 코디네이터가 복구하기를 기다리느라 멈출수 있으므로 블로킹 원자적 커밋 프로토콜이라고도 함 → 논블로킹 원자적 커밋 프로토콜이 가능할까?
  * 3PC → 지연에 제한이 있는 네트워크와 응답 시간에 제한이 있는 노드를 가정한 논블로킹 원자적 커밋 프로토콜
    * 그러나 대부분 실용적 시스템에서 원자성을 보장하지 못함
    * 논블로킹 원자적 커밋은 완벽한 실패감지기가 필요함 → 기약 없는 지연이 있는 네트워크에서 타임아웃은 신뢰성 있는 실패감지기가 아니라는 문제가 있음

#### 현실의 분산 트랜잭션

* 분산 트랜잭션은 성능이 매우 안좋음
  * MySQL의 경우 단일 트랜잭션에 비해 10배까지 느려짐
  * 2단계 커밋의 경우 장애 복구에 필요한 디스크 쓰기에와 부가적 네트워크 왕복시간으로 인해 성능이 매우 느려짐
* 이종 분산 트랜잭션
  * 다양한 시스템들이 강력한 방법으로 통합될 수 있게 함
    * 예시 - DB 트랜잭션이 커밋에 성공했을 떄만 메시지큐의 메시지를 처리
  * 단, 이런 트랜잭션은 모든 시스템이 동일한 원자적 커밋 프로토콜을 사용할 수 있을때만 가능함
    * 예시 - 메시지큐의 메시지가 실패하고 재시도해서 성공할때, 이메일서버에서는 이메일을 2번 보낼 수 있음
* XA 트랜잭션 - 이종 기술에 걸친 2단계 커밋을 구현하는 표준
  * XA는 프로토콜이 아닌 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 CAPI임
  * 자바에서는 JTA를 사용해 구현됨
  * 트랜잭션 코디네이터는 XA API를 구현하여 처리
  * XA 트랜잭션은 코디네이터 자체가 트랜잭션의 결과를 저장하는 일종의 DB여야 한다는 운영상 문제가 있음 → SPOF가 되지 않도록 주의해야 함
* 의심스러운 상황에서 잠금 처리
  * DB 트랜잭션은 보통 더티쓰기를 막기위해 변경한 로우에 로우 수준 독점적인 잠금을 획득함, 직렬성 격리의 경우 읽은 로우에 공유잠금도 획득함
  * DB는 트랜잭션이 커밋되거나 어보트 되기 전까지 해당 잠금을 해제할 수 없음 → 의심스러운 트랜잭션이 해소될때까지 어플리케이션의 처리를 막음
  * 이론상으로는 코디네이터가 죽은 후 재시작시 의심스러운 트랜잭션을 모두 복구해야하지만, 현실에서는 고아 트랜잭션이 생길 수 있음
    * 2PC의 올바른 구현은 DB 서버 재시작시에도 의심스러운 트랜잭션의 잠금을 유지해야하는 문제가 있음
  * 유일한 방법은 관리자가 수동으로 해당 트랜잭션을 커밋할지 롤백할지 결정하는 것
  * 여러 XA 구현에서는 의심스러운 트랜잭션을 어떻게 처리할지에 대한 경험적 결정 매커니즘이 있음
    * 경험적이란 2단계 커밋의 약속을 깨는, 원자성을 꺨 수 있는 결정임

#### 내결함성을 지닌 합의

* 합의 문제는 보통 아래와 같이 형식화됨
  * 하나 또는 그 이상의 노드들이 값을 제안하고, 합의 알고리즘이 그 중 하나를 결정
* 합의 알고리즘은 아래 속성을 만족해야함
  * 균일한 동의 - 어떤 두 노드도 다르게 결정하지 않음
  * 무결성 - 어떤 노드도 두번 결정하지 않음
  * 유효성 - 한 노드가 결정한 값 v는 반드시 어떤 노드에서 제안한 것임
  * 종료 - 죽지 않은 모든 노드는 값을 결정해야 함
* 균일한 동의, 무결성은 합의의 핵심 아이디어를 정의함
* 종료 속성은 내결함성의 아이디어를 형식화 함 → 어떤 노드가 장애가 나더라도 다른 노드는 결정을 내려야 함
* 합의 시스템에서는 노드가 죽을 경우, 해당 노드는 결코 돌아오지 않는다고 가정함
* 또한, 대부분의 합의 알고리즘은 비잔틴 결함이 없다고 가정함
* 뷰스탬프 복제, 팍소스, 라프트 등의 알고리즘이 있음
  * 형식적 모델을 직접 사용하지는 않음
  * 값의 시퀀스에 대해 결정한 후, 전체순서 브로드캐스트 알고리즘을 만듬
* 단일 리더 복제에서 스플릿 브레인 문제를 어떻게 해결하나?
  * 합의 프로토콜은 에포크 번호를 정의하고 각 에포크내에서는 리더가 유일하다고 보장.
  * 현재 리더가 죽었다고 생각될 때마다 새 노드 선출 투표 진행
  * 다른 에포크 간의 리더가 다르면 에포크 번호가 높은 리더가 이김
  * 리더가 어떤 결정을 하기 전에 에포크 번호가 더 높은 다른 리더가 있는지 확인함
* 합의 알고리즘의 단점
  * 제안이 결정되기 전에 노드가 제안에 투표하는 과정은 일종의 동기식 복제 → 성능 저하
  * 항상 과반수가 동작행 함
  * 대부분의 합의 알고리즘은 투표에 참여하는 노드 집합이 고정되어 있다고 가정함 → 클러스터에 노드를 추가하거나 제거할 수 없음
  * 장애노드를 감지하기 위해 일반적으로 타임아웃에 의존 → 리더에 장애가 발생했다고 잘못 생각할 수 있음
  * 네트워크 문제에 특히 민감함
* 멤버십과 코디네이션 서비스
  * 주키퍼, etcd는 메모리에 들어갈 수있는 적은양의 데이터를 보관하도록 설계
    * 해당 데이터는 전체순서 브로드캐스트 알고리즘을 통해 모든 노드에 복제됨
  * 주키퍼는 처비 잠금서비스를 모델로 여러 기능을 구현함
    * 선형성 원자적 연산
    * 연산의 전체 순서화
    * 장애감지
    * 변경알림
  * 주키퍼/처비 모델의 장점
    * 여러개의 프로세스나 서비스가 있고 그중 하나가 리더로 선택되어야 할 때 잘 동작함
    * 파티셔닝된 자원이 있고 어떤 파티션을 어떤 노드에 할당해야할지 결정 → 원자적 연산, 단명노드, 알림을 통해 해결함
  * 주키퍼, etcd, consul은 서비스 디스커버리에도 자주 사용됨
  * 주키퍼와 유사 프로젝트는 오랜 멤버십 서비스 연구 역사의 일부임
    * 멤버십 서비스는 클러스터에서 어떤 노드가 현재 활성화된 멤버인지 결정함 → 장애 감지를 합의와 연결하면 노드들은 해당 노드가 활성/비활성인지에 동의할 수 있음
