# 6장. 파티셔닝

#### 파티셔닝

* 보통은 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장 → 내결함성 보장
* 키-값 데이터 파티셔닝
  * 불균형하게 부하가 높은 파티션(핫스팟)을 피해야 함
  * 레코드를 할당할 노드를 무작위로 선택할 경우 특정 레코드가 어떤 노드에 저장되어있는지 알기 위해 모든 노드에서 병렬로 질의해야함
  * 키 범위 기준 파티셔닝
    * 각 파티션에 연속된 범위의 키를 할당 - 파티션 경계는 자동 / 수동으로 가능
    * 각 파티션 내에서는 키를 정렬된 순서로 저장 가능 - 범위 스캔 쉬워짐, 질의 하나로 레코드 여러개 읽기 가능
    * 특정한 접근 패턴이 핫스팟을 유발할 수 있음
  * 키의 해시값 기준 파티셔닝
    * 쏠림, 핫스팟 위험으로 인해 많은 경우 해시 함수를 사용
    * 키를 파티션 사이에 균일하게 분산(컨시스턴트 해싱)
    * 해시값 사용시 범위 질의를 효율적으로 하기는 어려운 단점이 있음
    * 카산드라의 경우 여러 칼럼을 포함하는 복합 기본키를 지정하고 키의 첫 부분에만 해싱을 적용하는 형태로 타협
    * 데이터 시스템으로는 작업부하를 자동 보정하지 못하므로 애플리케이션 단에서 쏠림을 완화해야함
      * 각 키의 시작이나 끝에 임의의 숫자를 붙이는 방법도 가능

#### 보조 색인

* 보조 색인은 파티션에 깔끔하게 대응되지 않음
* 문서기반 파티셔닝, 용어기반 파티셔닝을 사용
* 문서 기반 파티셔닝
  * 지역색인이라고도 함 - 각 파티션이 자신의 보조 색인을 유지하며, 그 파티션에 속하는 문서만 담당
  * 특정 색인의 값이 동일 파티션에 저장된다는 보장이 없음 → 모든 파티션에 질의를 보내야 함. 이를 스캐터/게더라고 함
    * 꼬리 지연시간 증폭이 발생하기 쉬움.
    * 그럼에도 몽고DB, 카산드라, ES 등이 문서기반 보조색인 사용
  * 보조 색인 질의가 단일 파티션에만 실행되도록 파티셔닝 방식 설계를 권장하지만 단일 질의에서 여러 보조 색인을 사용할 경우 어려움
* 용어 기준 파티셔닝
  * 모든 파티션의 데이터를 담당하는 전역 색인
  * 읽기가 효율적 - 스캐터/게더를 실행할 필요 X
  * 쓰기가 느리고 복잡함. - 단일 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있음
  * 현실에서는 전역 보조 색인은 대개 비동기로 갱신됨

#### 파티션 리밸런싱

* 처리량 증가, 장비 장애, 데이터 셋 크기 증가등으로 인해 특정 노드의 부하를 다른 노드로 옮겨야 함
* 리밸런싱 후 부하는 균등하게 분배되어야 하며, 리밸런싱 진행중에도 읽기/쓰기가 가능해야함. 리밸런싱이 빨리 되고, 네트워크와 디스크 I/O 부하 최소화를 위해 데이터가 필요 이상으로 옮겨지면 안됨
* 재균형화 전략
  * 해시값에 mod N 연산은 안됨 → 재균형화 비용이 지나치게 커짐
  * 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당.
    * 파티션은 노드 사이에서 통째로 이동하기만 한다.
    * 파티션 할당 변경에는 시간이 좀 소요됨 - 데이터 전송중의 읽기/쓰기 요청은 기존에 할당된 파티션을 사용
    * 고정 파티션을 사용하는 DB는 파티션 분할을 지원하지 않음 → 미래 데이터 용량을 생각해 파티션 개수 최초 설정시 충분히 높은값이어야 함
    * 적절한 파티션 개수를 잘 정해야 함
  * 동적 파티셔닝
    * 파티션 크기가 설정된 값을 넘어서면 두개로 쪼갠다.
    * 각 파티션은 노드 하나에 할당되고, 각 노드는 여러 파티션을 담당 가능
    * 동적 파티셔닝은 파티션 개수가 전체 데이터 용량에 맞춰 조정된다.
    * 그러나 빈 DB는 파티션이 하나라는 함정이 있음 → HBase와 몽고DB는 빈 DB에 초기 파티션 집합을 설정함
  * 노드 비례 파티셔닝
    * 파티션 개수가 노드 배수에 비례하게 함 → 노드당 파티션 개수를 고정
    * 새 노드 추가시에 고정된 개수의 파티션을 무작위로 선택해 2개로 분할
    * 균등하지 않은 분할이 생길수 있으나 평균적으로는 균등함
    * 해시기반 파티셔닝을 통해 파티션 경계를 무작위로 선택
  * 완전 자동 리밸런싱은 편리하지만 예측하기 어려움.
  * 요청 라우팅
    * 많은 분산 데이터 시스템은 클러스터 메타데이터 추적을 위해 주키퍼와 같은 코디네이션 서비스를 사용함
      * 파티션, 노드 변동시에 코디네이터에 알려서 최신 정보를 유지
    * 카산드라와 리악은 가십 프로토콜을 통해 클러스터 상태 변화를 노드 사이에 퍼트림 - 데이터베이스 노드의 복잡도는 올라가지만 외부 코디네이션 서비스 의존 X
