# 4장. 부호화와 발전

#### 호환성

* 데이터 타입과 스키마가 변경될때 하위호환성, 상위호환성을 모두 보장해주어야 함
* 메모리에 있는 객체, 구조체 등을 파일에 쓰거나 네트워크를 통해 전송하려면 일련의 바이트열의 형태(JSON 등)로 부호화 해야함
  * 부호화(마샬링): 인메모리 → 바이트열 / 복호화(언마샬링): 인메모리 → 바이트열
* 프로그래밍 언어에 내장된 라이브러리는 여러 문제점이 있음
  * 특정 프로그래밍 언어에 종속, 효율성이 떨어지는 문제등
* JSON, XML, CSV 등이 많이 사용됨
* 이진 부호화
  * JSON, XML은 많은 공간을 사용하는 문제가 있음
  * 특히 스키마를 지정하지 않으므로 데이터 안에 모든 객체의 필드명이 있어야 함
* 스리프트 / 프로토콜 버퍼
  * 이진 부호화 라이브러리이며, 부호화한 데이터를 위한 스키마가 필요함
  * 필드명이 없는 대신 숫자와 같은 필드 태그를 포함함
  * 각 필드에는 required 또는 optional로 표기해야함
  * 상/하위 호환성
    * 상위 호환성 - 필드에 새로운 태그번호를 부여하는 형태로 필드 추가
    * 하위 호환성 - 고유한 태그번호가 있으므로 새로운 코드가 예전 데이터 읽기 가능, 새로운 필드를 추가한 경우 이 필드를 required로 할 수 없음
    * repeated필드 → 단일 값인 optional을 repeated라는 리스트 형태로 변경해도 하위 호환성이 지원됨
* 아브로
  * 스키마에 태그번호가 없음, 바이트 열은 필드나 데이터타입을 식별할 정보가 없음
  * 쓰기 스키마와 읽기스키마를 다르게 가져갈 수 있음 → 스키마 해석에서는 이름으로 처리하기 때문
  * 아브로 읽기에서는 쓰기 스키마와 읽기 스키마를 비교해 데이터를 해석함
  * 아브로는 필드 태그가 없으므로 관계형 스키마로부터 아브로 스키마를 상당히 쉽게 생성 가능
    * 반면 스리프트/프로토콜 버퍼를 같은 용도로 사용한다면 DB 스키마가 변경될 때마다 관리자가 매번 DB 칼럼명과 필드 태그를 수동으로 매핑해야함
* 부호화 스키마는 XML,JSON 스키마보다 훨씬 간단하며 , 더 자세한 유효성 검사 규칙을 지원함
* 복호화시 스키마가 필요하므로 스키마가 최신상태인지 확인 가능

#### 데이터플로 모드

* 데이터플로 - 프로세스간 데이터를 전달하는 방법
  * 데이터베이스를 통한 데이터플로
    * 상/하위호환성 필요,
  * 서비스
    * REST와 RPC를 사용
    * 여러면에서 데이터베이스와 유사하나, 애플리케이션 특화 API가 약간의 캡슐화를 제공함
  * 웹 서비스
    * REST - HTTP 원칙을 토대로 한 설계철학. REST 원칙에 따라 설계된 API를 RESTful이라 함
    * SOAP - 네트워크 API 요청을 위한 XML 기반 프로토콜, WSDL을 사용해 기술함, 사람이 읽을수 없고, 수동으로 구성하기에 너무 복잡하여 코드생성과 IDE에 크게 의존함
    * RPC(원격 프로시저 호출)
      * 위치 투명성 : 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 함
      * 차세데 RPC 프레임워크는 원격 요청이 로컬 함수 호출과 다르다는 사실을 분명히 함
        * 퓨처/프로미스 - 병렬로 여러 서버스에 요청을 보내는 상황을 간소화하며, 요청 결과를 취합함
        * 이러한 프레임워크 중 일부는 서비스 디스커버리 지원
      * RPC 프로토콜이 Restful API보다 성능은 좋을수 있으나, Restful API는 실험,디버깅에 적합하며 다양한 도구생태계를 갖는 장점이 있음
        * 이로 인해 Rest가 주로 쓰이며 RPC는 같은 조직 내의 서비스 요청이 주로 사용
  * 메시지 전달
    * 메시지 브로커나 미들웨어라는 중간단계를 거침
    * 장점
      * 메시지 브로커가 버퍼처럼 동작할수 있으므로 시스템 안정성 향상
      * 메시지 유실 방지, 하나의 메시지를 여러 수신자로 전송 가능
      * 송신자와 수신자가 논리적으로 분리됨
  * 메시지 브로커
    * 단방향 데이터플로 제공, 특정 데이터 모델 강요X → 유연성
  * 분산액터 프레임워크(아카, 얼랭 등)
    * 메시지 브로커와 액터 프로그래밍 모델을 통합하여 처리하는
    * 액터 모델은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델을 뜻함
      * 스레드를 직접 처리하는 대신 로직이 액터에 캡슐화됨
      * 보통 각 액터는 하나의 클라이언트나 엔티티
      * 액터는 메시지 전달을 보장하지 않음
